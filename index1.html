<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Metalero con power-ups y joysticks multitouch</title>
<style>
  /* Reset y base */
  body {
    margin: 0;
    background: #111;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    user-select: none;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 10px;
    box-sizing: border-box;
  }
  #instructions {
    font-size: 14px;
    max-width: 90vw;
    text-align: center;
    background: rgba(0,0,0,0.6);
    padding: 8px 15px;
    border-radius: 8px;
    margin-bottom: 10px;
    line-height: 1.3;
  }
  a {
    color: #a22;
    text-decoration: none;
    font-weight: bold;
  }
  a:hover {
    text-decoration: underline;
  }
  #backLink {
    margin-bottom: 10px;
    user-select: none;
  }
  canvas {
    background: #222;
    border: 2px solid #555;
    touch-action: none;
    max-width: 100vw;
    width: 100%;
    max-height: 60vh;
    border-radius: 10px;
    box-shadow: 0 0 15px #a22;
  }
  #score {
    font-family: monospace;
    font-size: 22px;
    text-align: center;
    color: white;
    background: rgba(0,0,0,0.6);
    padding: 8px 0;
    border-radius: 10px;
    width: 100%;
    max-width: 600px;
    margin-top: 12px;
    user-select: none;
    box-shadow: 0 0 10px #700;
  }
  #pauseOverlay {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    color: white;
    font-size: 28px;
    font-weight: bold;
    user-select: none;
    visibility: hidden;
    z-index: 100;
    padding: 20px;
    box-sizing: border-box;
    text-align: center;
  }
  #resumeBtn {
    margin-top: 25px;
    padding: 12px 30px;
    background: #a22;
    border: none;
    color: white;
    font-size: 20px;
    cursor: pointer;
    border-radius: 8px;
    box-shadow: 0 0 15px #a22;
  }
  #resumeBtn:hover {
    background: #d33;
  }
  #btnPauseMobile {
    position: fixed;
    top: 10px;
    right: 10px;
    background: #a22;
    width: 50px;
    height: 50px;
    border-radius: 10px;
    font-size: 28px;
    line-height: 50px;
    text-align: center;
    cursor: pointer;
    z-index: 30;
    user-select: none;
    box-shadow: 0 0 10px #700;
  }
  #btnPauseMobile:active {
    background: #d33;
    box-shadow: 0 0 15px #d33;
  }
  .joystickContainer {
    position: fixed;
    bottom: 20px;
    width: 110px;
    height: 110px;
    touch-action: none;
    user-select: none;
    z-index: 25;
    background: #444;
    border-radius: 50%;
    opacity: 0.65;
    box-shadow: 0 0 20px #a22;
  }
  .joystickStick {
    width: 55px;
    height: 55px;
    background: #a22;
    border-radius: 50%;
    position: absolute;
    left: 27px;
    top: 27px;
    box-shadow: 0 0 15px #700;
    touch-action: none;
  }
  #joystickMove {
    left: 15px;
    bottom: 20px;
  }
  #joystickAim {
    right: 15px;
    bottom: 20px;
  }

  /* Ajustes para pantallas pequeñas (celulares) */
  @media (max-width: 450px) {
    #instructions {
      font-size: 12px;
      padding: 6px 10px;
    }
    #score {
      font-size: 18px;
      padding: 6px 0;
    }
    .joystickContainer {
      width: 90px;
      height: 90px;
      opacity: 0.7;
    }
    .joystickStick {
      width: 45px;
      height: 45px;
      left: 22px;
      top: 22px;
    }
    #btnPauseMobile {
      width: 44px;
      height: 44px;
      font-size: 24px;
      line-height: 44px;
      border-radius: 8px;
      top: 8px;
      right: 8px;
    }
  }
</style>
</head>
<body>
  <div id="backLink"><a href="/index.html">Volver al inicio</a></div>

  <div id="instructions">
    Usa joystick izquierdo para mover<br>
    Usa joystick derecho para apuntar y disparar<br>
    P para pausar o botón arriba a la derecha<br>
    Recoge power-ups morados para balas más grandes por 10 segundos
  </div>

  <canvas id="game" width="600" height="400"></canvas>

  <div id="score">Puntaje: 0</div>

  <div id="pauseOverlay">
    <div>Juego en pausa</div>
    <button id="resumeBtn">Reanudar</button>
  </div>

  <div id="btnPauseMobile" title="Pausar">⏸</div>

  <div id="joystickMove" class="joystickContainer">
    <div class="joystickStick"></div>
  </div>
  <div id="joystickAim" class="joystickContainer">
    <div class="joystickStick"></div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Jugador
  const player = {
    x: canvas.width / 2,
    y: canvas.height - 60,
    speed: 5,
    vx: 0
  };

  // Puntero para apuntar y disparar
  const pointer = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    down: false
  };

  // Teclas para movimiento PC
  const keys = {
    left: false,
    right: false
  };

  const bullets = [];
  const enemies = [];
  const powerUps = [];

  let score = 0;
  let lastShot = 0;
  const fireRate = 200;

  let gamePaused = false;
  let animationFrameId = null;
  let spawnInterval = null;
  let powerUpTimeout = null;
  let powerUpActive = false;
  let gameOver = false;

  const pauseOverlay = document.getElementById('pauseOverlay');
  const resumeBtn = document.getElementById('resumeBtn');
  const btnPauseMobile = document.getElementById('btnPauseMobile');

  const joystickMove = document.querySelector('#joystickMove');
  const joystickMoveStick = joystickMove.querySelector('.joystickStick');
  const joystickAim = document.querySelector('#joystickAim');
  const joystickAimStick = joystickAim.querySelector('.joystickStick');

  // Variables multitouch: id del dedo activo para cada joystick o null si libre
  let moveTouchId = null;
  let aimTouchId = null;

  let moveCenter = { x: 0, y: 0 };
  let aimCenter = { x: 0, y: 0 };

  let movePos = { x: 0, y: 0 };
  let aimPos = { x: 0, y: 0 };

  // Inicializar centros joystick
  function initJoystickCenters() {
    const rectMove = joystickMove.getBoundingClientRect();
    moveCenter.x = rectMove.left + rectMove.width / 2;
    moveCenter.y = rectMove.top + rectMove.height / 2;
    resetMoveJoystick();

    const rectAim = joystickAim.getBoundingClientRect();
    aimCenter.x = rectAim.left + rectAim.width / 2;
    aimCenter.y = rectAim.top + rectAim.height / 2;
    resetAimJoystick();
  }

  // Reset joystick movimiento
  function resetMoveJoystick() {
    joystickMoveStick.style.transform = 'translate(0px, 0px)';
    movePos.x = 0;
    movePos.y = 0;
    keys.left = false;
    keys.right = false;
    moveTouchId = null;
  }

  // Reset joystick apuntado
  function resetAimJoystick() {
    joystickAimStick.style.transform = 'translate(0px, 0px)';
    aimPos.x = 0;
    aimPos.y = 0;
    pointer.down = false;
    aimTouchId = null;
  }

  // Actualizar movimiento jugador según movePos.x (-1 a 1)
  function updatePlayerFromMoveJoystick() {
    if (movePos.x < -0.3) {
      keys.left = true;
      keys.right = false;
    } else if (movePos.x > 0.3) {
      keys.left = false;
      keys.right = true;
    } else {
      keys.left = false;
      keys.right = false;
    }
  }

  // Actualizar puntero según aimPos
  function updatePointerFromAimJoystick() {
    if (aimPos.x === 0 && aimPos.y === 0) {
      pointer.down = false; // no apunta ni dispara si no movió joystick
      return;
    }
    pointer.down = true;
    pointer.x = player.x + aimPos.x * 100;
    pointer.y = player.y + aimPos.y * 100;
    pointer.x = Math.min(Math.max(pointer.x, 0), canvas.width);
    pointer.y = Math.min(Math.max(pointer.y, 0), canvas.height);
  }

  // Manejo multitouch para joystick movimiento
  joystickMove.addEventListener('touchstart', e => {
    e.preventDefault();
    initJoystickCenters();
    for (const touch of e.changedTouches) {
      if (moveTouchId === null && isTouchInside(touch, joystickMove)) {
        moveTouchId = touch.identifier;
        handleMoveJoystick(touch);
        break;
      }
    }
  }, {passive: false});

  joystickMove.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      if (touch.identifier === moveTouchId) {
        handleMoveJoystick(touch);
        break;
      }
    }
  }, {passive: false});

  joystickMove.addEventListener('touchend', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      if (touch.identifier === moveTouchId) {
        resetMoveJoystick();
        break;
      }
    }
  }, {passive: false});
  joystickMove.addEventListener('touchcancel', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      if (touch.identifier === moveTouchId) {
        resetMoveJoystick();
        break;
      }
    }
  }, {passive: false});

  // Manejo multitouch para joystick apuntado
  joystickAim.addEventListener('touchstart', e => {
    e.preventDefault();
    initJoystickCenters();
    for (const touch of e.changedTouches) {
      if (aimTouchId === null && isTouchInside(touch, joystickAim)) {
        aimTouchId = touch.identifier;
        handleAimJoystick(touch);
        break;
      }
    }
  }, {passive: false});

  joystickAim.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      if (touch.identifier === aimTouchId) {
        handleAimJoystick(touch);
        break;
      }
    }
  }, {passive: false});

  joystickAim.addEventListener('touchend', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      if (touch.identifier === aimTouchId) {
        resetAimJoystick();
        break;
      }
    }
  }, {passive: false});
  joystickAim.addEventListener('touchcancel', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      if (touch.identifier === aimTouchId) {
        resetAimJoystick();
        break;
      }
    }
  }, {passive: false});

  // Helper para saber si un touch está dentro del contenedor joystick
  function isTouchInside(touch, container) {
    const rect = container.getBoundingClientRect();
    return (
      touch.clientX >= rect.left &&
      touch.clientX <= rect.right &&
      touch.clientY >= rect.top &&
      touch.clientY <= rect.bottom
    );
  }

  function handleMoveJoystick(touch) {
    const dx = touch.clientX - moveCenter.x;
    const dy = touch.clientY - moveCenter.y;
    const maxDist = 50;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > maxDist) dist = maxDist;
    const angle = Math.atan2(dy, dx);
    const stickX = Math.cos(angle)*dist;
    const stickY = Math.sin(angle)*dist;
    joystickMoveStick.style.transform = `translate(${stickX}px, ${stickY}px)`;
    movePos.x = stickX / maxDist;
    movePos.y = stickY / maxDist;
    updatePlayerFromMoveJoystick();
  }

  function handleAimJoystick(touch) {
    const dx = touch.clientX - aimCenter.x;
    const dy = touch.clientY - aimCenter.y;
    const maxDist = 50;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > maxDist) dist = maxDist;
    const angle = Math.atan2(dy, dx);
    const stickX = Math.cos(angle)*dist;
    const stickY = Math.sin(angle)*dist;
    joystickAimStick.style.transform = `translate(${stickX}px, ${stickY}px)`;
    aimPos.x = stickX / maxDist;
    aimPos.y = stickY / maxDist;
    updatePointerFromAimJoystick();
  }

  // Teclado PC para mover y pausar
  window.addEventListener('keydown', e => {
    if (e.key === 'a' || e.key === 'ArrowLeft') keys.left = true;
    if (e.key === 'd' || e.key === 'ArrowRight') keys.right = true;
    if (e.key.toLowerCase() === 'p') {
      if (gamePaused) resumeGame();
      else pauseGame();
    }
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'a' || e.key === 'ArrowLeft') keys.left = false;
    if (e.key === 'd' || e.key === 'ArrowRight') keys.right = false;
  });

  // Mouse apuntado y disparo
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    pointer.x = e.clientX - rect.left;
    pointer.y = e.clientY - rect.top;
  });
  canvas.addEventListener('mousedown', e => {
    if (e.button === 0) pointer.down = true;
  });
  canvas.addEventListener('mouseup', e => {
    if (e.button === 0) pointer.down = false;
  });

  // Touch canvas para disparar apuntado (opcional)
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    pointer.x = touch.clientX - rect.left;
    pointer.y = touch.clientY - rect.top;
    pointer.down = true;
  }, {passive: false});
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    pointer.x = touch.clientX - rect.left;
    pointer.y = touch.clientY - rect.top;
  }, {passive: false});
  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    pointer.down = false;
  }, {passive: false});

  // Botón pausa
  btnPauseMobile.addEventListener('click', () => {
    if (gamePaused) resumeGame();
    else pauseGame();
  });

  // Función para crear un power-up
  function spawnPowerUp() {
    if (gamePaused || gameOver) return;
    const x = Math.random() * (canvas.width - 30) + 15;
    powerUps.push({
      x,
      y: -20,
      size: 20,
      speed: 2,
      active: true
    });
  }
  function startSpawning() {
    spawnInterval = setInterval(() => {
      spawnEnemy();
      // Cada 10 segundos chance de power-up
      if (Math.random() < 0.25) spawnPowerUp();
    }, 1000);
  }
  function stopSpawning() {
    clearInterval(spawnInterval);
  }
  function spawnEnemy() {
    if (gamePaused || gameOver) return;
    const x = Math.random() * (canvas.width - 30) + 15;
    enemies.push({
      x,
      y: -20,
      size: 30,
      speed: 2 + Math.random() * 1.5
    });
  }

  // Actualizar jugador
  function updatePlayer() {
    if (keys.left) player.vx = -player.speed;
    else if (keys.right) player.vx = player.speed;
    else player.vx = 0;

    player.x += player.vx;
    player.x = Math.min(Math.max(player.x, 20), canvas.width - 20);
  }

  // Actualizar balas
  function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += Math.cos(b.angle) * b.speed;
      b.y += Math.sin(b.angle) * b.speed;

      if (
        b.x < 0 || b.x > canvas.width ||
        b.y < 0 || b.y > canvas.height
      ) {
        bullets.splice(i, 1);
      }
    }
  }

  // Actualizar enemigos y power-ups
  function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.y += e.speed;

      // Colisión con jugador - game over
      const dx = e.x - player.x;
      const dy = e.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < e.size + 20) {
        gameOver = true;
        pauseGame();
        pauseOverlay.firstElementChild.textContent = "¡Perdiste! Puntos: " + score;
        return;
      }

      // Enemigo pasa abajo -> pierde punto
      if (e.y > canvas.height + e.size) {
        enemies.splice(i, 1);
        score = Math.max(0, score - 1);
        document.getElementById('score').textContent = `Puntaje: ${score}`;
      }
    }

    for (let i = powerUps.length - 1; i >= 0; i--) {
      const p = powerUps[i];
      p.y += p.speed;

      // Colisión con jugador -> activar power-up
      const dx = p.x - player.x;
      const dy = p.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < p.size + 20) {
        powerUps.splice(i, 1);
        activatePowerUp();
      }

      // Power-up pasa abajo -> simplemente eliminar
      if (p.y > canvas.height + p.size) {
        powerUps.splice(i, 1);
      }
    }
  }

  // Detectar colisiones balas - enemigos
  function checkCollisions() {
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        const dx = e.x - b.x;
        const dy = e.y - b.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < e.size + b.size) {
          enemies.splice(i, 1);
          bullets.splice(j, 1);
          score++;
          document.getElementById('score').textContent = `Puntaje: ${score}`;
          break;
        }
      }
    }
  }

  // Función disparar
  function shoot(time) {
    if (time - lastShot > fireRate && pointer.down && !gamePaused && !gameOver) {
      bullets.push({
        x: player.x,
        y: player.y - 15,
        size: powerUpActive ? 14 : 6,
        speed: 8,
        angle: Math.atan2(pointer.y - player.y, pointer.x - player.x)
      });
      lastShot = time;
    }
  }

  // Dibujar jugador metálico con guitarra y cabello
  function drawPlayer() {
    ctx.save();
    ctx.translate(player.x, player.y);

    // Cuerpo
    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.ellipse(0, 0, 20, 35, 0, 0, Math.PI * 2);
    ctx.fill();

    // Cabeza
    ctx.fillStyle = '#555';
    ctx.beginPath();
    ctx.ellipse(0, -45, 15, 18, 0, 0, Math.PI * 2);
    ctx.fill();

    // Ojos blancos
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(-6, -48, 5, 7, 0, 0, Math.PI * 2);
    ctx.ellipse(6, -48, 5, 7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pupilas negras mirando puntero
    let eyeDirX = pointer.x - player.x;
    let eyeDirY = pointer.y - (player.y - 48);
    let eyeAngle = Math.atan2(eyeDirY, eyeDirX);
    let pupilOffsetX = Math.cos(eyeAngle) * 2;
    let pupilOffsetY = Math.sin(eyeAngle) * 2;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.ellipse(-6 + pupilOffsetX, -48 + pupilOffsetY, 2.5, 3.5, 0, 0, Math.PI * 2);
    ctx.ellipse(6 + pupilOffsetX, -48 + pupilOffsetY, 2.5, 3.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Boca sonriente
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-6, -33);
    ctx.quadraticCurveTo(0, -25, 6, -33);
    ctx.stroke();

    // Cabello largo y negro (metalero)
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.moveTo(-18, -60);
    ctx.bezierCurveTo(-12, -90, 12, -90, 18, -60);
    ctx.lineTo(18, -40);
    ctx.bezierCurveTo(12, -70, -12, -70, -18, -40);
    ctx.closePath();
    ctx.fill();

    // Sombrero (gorro de lana negro)
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.ellipse(0, -70, 20, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Guitarra (arma)
    ctx.strokeStyle = '#a22';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';

    // Cuerpo guitarra
    ctx.beginPath();
    ctx.moveTo(5, -15);
    ctx.lineTo(40, 0);
    ctx.lineTo(5, 20);
    ctx.closePath();
    ctx.fillStyle = '#800';
    ctx.fill();
    ctx.stroke();

    // Mango guitarra
    ctx.beginPath();
    ctx.moveTo(40, 0);
    ctx.lineTo(65, -10);
    ctx.lineTo(65, 10);
    ctx.lineTo(40, 0);
    ctx.stroke();

    // Cuerdas guitarra
    ctx.strokeStyle = '#ccc';
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(40 + i * 5, -10);
      ctx.lineTo(40 + i * 5, 10);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Dibujar balas
  function drawBullets() {
    ctx.fillStyle = '#f33';
    bullets.forEach(b => {
      ctx.beginPath();
      ctx.ellipse(b.x, b.y, b.size, b.size / 2, 0, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // Dibujar enemigos rojos
  function drawEnemies() {
    ctx.fillStyle = '#f00';
    enemies.forEach(e => {
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, e.size, e.size, 0, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // Dibujar power-ups morados
  function drawPowerUps() {
    ctx.fillStyle = '#a2a';
    powerUps.forEach(p => {
      ctx.beginPath();
      ctx.ellipse(p.x, p.y, p.size, p.size, 0, 0, Math.PI * 2);
      ctx.fill();

      // Cruz dentro del power-up
      ctx.strokeStyle = '#eee';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(p.x - p.size/2, p.y);
      ctx.lineTo(p.x + p.size/2, p.y);
      ctx.moveTo(p.x, p.y - p.size/2);
      ctx.lineTo(p.x, p.y + p.size/2);
      ctx.stroke();
    });
  }

  // Limpiar pantalla
  function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Función activar power-up (balas grandes por 10s)
  function activatePowerUp() {
    powerUpActive = true;
    // Cambiar color del score para aviso visual
    document.getElementById('score').style.color = '#a2a';
    if (powerUpTimeout) clearTimeout(powerUpTimeout);
    powerUpTimeout = setTimeout(() => {
      powerUpActive = false;
      document.getElementById('score').style.color = 'white';
    }, 10000);
  }

  // Loop principal juego
  function gameLoop(time = 0) {
    if (gamePaused) return;

    clear();

    updatePlayer();
    updateBullets();
    updateEnemies();
    checkCollisions();
    shoot(time);

    drawPlayer();
    drawBullets();
    drawEnemies();
    drawPowerUps();

    if (!gameOver) {
      animationFrameId = requestAnimationFrame(gameLoop);
    }
  }

  // Pausar juego
  function pauseGame() {
    gamePaused = true;
    pauseOverlay.style.visibility = 'visible';
    cancelAnimationFrame(animationFrameId);
    stopSpawning();
  }

  // Reanudar juego
  function resumeGame() {
    if (gameOver) return;
    gamePaused = false;
    pauseOverlay.style.visibility = 'hidden';
    animationFrameId = requestAnimationFrame(gameLoop);
    startSpawning();
  }

  // Reiniciar juego
  function restartGame() {
    score = 0;
    gameOver = false;
    powerUpActive = false;
    document.getElementById('score').textContent = `Puntaje: ${score}`;
    document.getElementById('score').style.color = 'white';
    pauseOverlay.firstElementChild.textContent = "Juego en pausa";
    enemies.length = 0;
    bullets.length = 0;
    powerUps.length = 0;
    player.x = canvas.width / 2;
    player.y = canvas.height - 60;
    resumeGame();
  }

  // Empezar generación enemigos y power-ups
  startSpawning();

  // Evento botón reanudar
  resumeBtn.addEventListener('click', resumeGame);

  // Inicializar joystick y actualizar al redimensionar ventana
  initJoystickCenters();
  window.addEventListener('resize', initJoystickCenters);

  // Función disparo llamada en loop
  function shoot(time) {
    if (time - lastShot > fireRate && pointer.down && !gamePaused && !gameOver) {
      bullets.push({
        x: player.x,
        y: player.y - 15,
        size: powerUpActive ? 14 : 6,
        speed: 8,
        angle: Math.atan2(pointer.y - player.y, pointer.x - player.x)
      });
      lastShot = time;
    }
  }

  // Comentar cada función / línea si querés que te explique
});
</script>
</body>
</html>
